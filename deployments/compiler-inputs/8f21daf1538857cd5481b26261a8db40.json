{
	"solcVersion": "0.8.17",
	"solcLongVersion": "0.8.17",
	"id": "8f21daf1538857cd5481b26261a8db40",
	"input": {
		"language": "Solidity",
		"settings": {
			"viaIR": false,
			"optimizer": {
				"runs": 999999,
				"enabled": true
			},
			"metadata": {
				"useLiteralContent": false,
				"bytecodeHash": "ipfs"
			},
			"outputSelection": {
				"lib/ORMP/src/Channel.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/ORMP/src/Common.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/ORMP/src/ORMP.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/ORMP/src/UserConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/ORMP/src/Verifier.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/ORMP/src/eco/Oracle.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/ORMP/src/eco/Relayer.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/ORMP/src/interfaces/IORMP.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/ORMP/src/interfaces/IOracle.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/ORMP/src/interfaces/IRelayer.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/ORMP/src/interfaces/IVerifier.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/ORMP/src/security/ExcessivelySafeCall.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/ORMP/src/security/ReentrancyGuard.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/ORMP/src/user/AppBase.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/XAccount/src/SafeMsgportModule.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/XAccount/src/XAccountFactory.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/XAccount/src/XAccountUIFactory.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/XAccount/src/interfaces/ISafe.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/XAccount/src/interfaces/ISafeMsgportModule.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/XAccount/src/interfaces/ISafeProxyFactory.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/XAccount/src/interfaces/IXAccountFactory.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/XAccount/src/user/xAuth.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/XAccount/src/utils/CREATE3.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/create3-deploy/src/CREATE3Factory.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/create3-deploy/src/ICREATE3Factory.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/darwinia-msgport/lib/solmate/src/utils/Bytes32AddressLib.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/darwinia-msgport/lib/solmate/src/utils/CREATE3.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/darwinia-msgport/src/interfaces/IMessagePort.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/darwinia-msgport/src/interfaces/IPortMetadata.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/darwinia-msgport/src/interfaces/IPortRegistry.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/darwinia-msgport/src/ports/MultiPort.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/darwinia-msgport/src/ports/ORMPUpgradeablePort.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/darwinia-msgport/src/ports/base/BaseMessagePort.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/darwinia-msgport/src/ports/base/PeerLookup.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/darwinia-msgport/src/ports/base/PortMetadata.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/darwinia-msgport/src/user/Application.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/Base.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/Script.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdChains.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdCheats.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdJson.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdMath.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdStorage.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdStyle.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdToml.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdUtils.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/Vm.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/console.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/console2.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/interfaces/IERC165.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/interfaces/IERC20.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/interfaces/IERC721.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/interfaces/IMulticall3.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/mocks/MockERC20.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/mocks/MockERC721.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/safeconsole.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/openzeppelin-contracts/contracts/utils/Context.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/openzeppelin-contracts/contracts/utils/Strings.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/openzeppelin-contracts/contracts/utils/math/Math.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/sphinx/packages/contracts/contracts/core/SphinxDataTypes.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/sphinx/packages/contracts/contracts/core/interfaces/ISphinxModule.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/sphinx/packages/contracts/contracts/core/interfaces/ISphinxModuleProxyFactory.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/sphinx/packages/contracts/contracts/forge-std/src/StdUtils.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/sphinx/packages/contracts/contracts/forge-std/src/Vm.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/sphinx/packages/contracts/contracts/forge-std/src/interfaces/IERC165.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/sphinx/packages/contracts/contracts/forge-std/src/interfaces/IERC20.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/sphinx/packages/contracts/contracts/forge-std/src/interfaces/IERC721.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/sphinx/packages/contracts/contracts/forge-std/src/interfaces/IMulticall3.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/sphinx/packages/contracts/contracts/forge-std/src/mocks/MockERC20.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/sphinx/packages/contracts/contracts/forge-std/src/mocks/MockERC721.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/sphinx/packages/contracts/contracts/foundry/Sphinx.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/sphinx/packages/contracts/contracts/foundry/SphinxConstants.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/sphinx/packages/contracts/contracts/foundry/SphinxForkCheck.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/sphinx/packages/contracts/contracts/foundry/SphinxPlugin.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/sphinx/packages/contracts/contracts/foundry/SphinxPluginTypes.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/sphinx/packages/contracts/contracts/foundry/SphinxUtils.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/sphinx/packages/contracts/contracts/foundry/interfaces/ICreateCall.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/sphinx/packages/contracts/contracts/foundry/interfaces/IEnum.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/sphinx/packages/contracts/contracts/foundry/interfaces/IGnosisSafe.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/sphinx/packages/contracts/contracts/foundry/interfaces/IGnosisSafeProxy.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/sphinx/packages/contracts/contracts/foundry/interfaces/IGnosisSafeProxyFactory.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/sphinx/packages/contracts/contracts/foundry/interfaces/IMultiSend.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/subapi/lib/safe-smart-account/contracts/base/OwnerManager.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/subapi/lib/safe-smart-account/contracts/common/SelfAuthorized.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/subapi/src/SubAPIMultiSig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"script/Proposal.s.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"script/common/Base.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"script/common/TomlTools.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"script/x-account/Deploy.s.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/Msgport.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/XAccount.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				}
			},
			"evmVersion": "london",
			"libraries": {},
			"remappings": [
				"subapi/=lib/subapi/",
				"ORMP/=lib/ORMP/",
				"@darwinia-msgport/=lib/darwinia-msgport/",
				"@msgport/=lib/darwinia-msgport/src/",
				"@openzeppelin/contracts@4.9.2/=lib/openzeppelin-contracts/contracts/",
				"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
				"@safe-smart-account/=lib/subapi/lib/safe-smart-account/contracts/",
				"@sphinx-labs/contracts/=lib/sphinx/packages/contracts/contracts/foundry/",
				"@x-account/=lib/XAccount/src/",
				"forge-std/=lib/forge-std/src/",
				"solmate/=lib/darwinia-msgport/lib/solmate/src/",
				"create3-deploy/=lib/create3-deploy/"
			]
		},
		"sources": {
			"lib/XAccount/src/SafeMsgportModule.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./interfaces/ISafe.sol\";\nimport \"./user/xAuth.sol\";\n\ncontract SafeMsgportModule is xAuth {\n    address public port;\n\n    address public childXAccount;\n    uint256 public rootChainid;\n    address public rootOwner;\n\n    event SetPort(address port);\n    event ModuleTransactionExecuted(address target, uint256 value, bytes data, Operation operation, bool result);\n\n    error AlreadySetup();\n    error ZeroChainId();\n    error SendEtherFailed(bytes reason);\n\n    constructor() {\n        rootChainid = 1;\n    }\n\n    function setup(address xAccount, uint256 chainId, address owner, address port_) external {\n        if (rootChainid > 0) {\n            revert AlreadySetup();\n        }\n        if (chainId == 0) {\n            revert ZeroChainId();\n        }\n        port = port_;\n        childXAccount = xAccount;\n        rootChainid = chainId;\n        rootOwner = owner;\n        emit SetPort(port_);\n    }\n\n    /// @dev Fetch the xAccount xOwner.\n    /// @return (chainId, owner)\n    ///   - chainId Chain id that xAccount belongs in.\n    ///   - owner Owner that xAccount belongs to.\n    function xOwner() public view override returns (uint256, address) {\n        return (rootChainid, rootOwner);\n    }\n\n    /// @dev Check that the xCall originates from the port.\n    /// @return Check result.\n    function checkPort(address port_) public view override returns (bool) {\n        return port == port_;\n    }\n\n    /// @dev Set port.\n    /// @param port_ New port.\n    function setPort(address port_) external {\n        _checkXAuth();\n        port = port_;\n        emit SetPort(port_);\n    }\n\n    /// @dev Receive xCall from root chain xOwner.\n    /// @param target Target of the transaction that should be executed\n    /// @param value Wei value of the transaction that should be executed\n    /// @param data Data of the transaction that should be executed\n    /// @param operation Operation (Call or Delegatecall) of the transaction that should be executed\n    /// @return xExecute return data Return data after xCall.\n    function xExecute(address target, uint256 value, bytes calldata data, Operation operation)\n        external\n        payable\n        returns (bytes memory)\n    {\n        _checkXAuth();\n        if (msg.value > 0) {\n            (bool s, bytes memory r) = childXAccount.call{value: msg.value}(\"\");\n            if (!s) revert SendEtherFailed(r);\n        }\n        (bool success, bytes memory returnData) =\n            ISafe(childXAccount).execTransactionFromModuleReturnData(target, value, data, operation);\n        emit ModuleTransactionExecuted(target, value, data, operation, success);\n        return returnData;\n    }\n}\n"
			},
			"lib/XAccount/src/interfaces/ISafe.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nenum Operation {\n    Call,\n    DelegateCall\n}\n\ninterface ISafe {\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    ) external;\n    function enableModule(address module) external;\n    function execTransactionFromModuleReturnData(address to, uint256 value, bytes memory data, Operation operation)\n        external\n        returns (bool success, bytes memory returnData);\n}\n"
			},
			"lib/XAccount/src/user/xAuth.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"@msgport/user/Application.sol\";\nimport \"@msgport/interfaces/IPortRegistry.sol\";\n\nabstract contract xAuth is Application {\n    function xOwner() public virtual returns (uint256, address);\n    function checkPort(address port) public virtual returns (bool);\n\n    function _checkXAuth() internal virtual {\n        address port = _msgPort();\n        uint256 fromChainId = _fromChainId();\n        (uint256 chainId, address owner) = xOwner();\n        require(fromChainId != block.chainid, \"!fromChainId\");\n        require(checkPort(port), \"!trusted\");\n        require(fromChainId == chainId, \"!xOwner.chainId\");\n        require(_xmsgSender() == owner, \"!xOwner.owner\");\n    }\n}\n"
			},
			"lib/darwinia-msgport/src/interfaces/IPortRegistry.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPortRegistry {\n    function get(uint256 chainId, address port) external view returns (string memory);\n    function get(uint256 chainId, string calldata name) external view returns (address);\n}\n"
			},
			"lib/darwinia-msgport/src/user/Application.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nabstract contract Application {\n    function _msgPort() internal view returns (address _port) {\n        _port = msg.sender;\n    }\n\n    function _messageId() internal pure returns (bytes32 _msgDataMessageId) {\n        require(msg.data.length >= 84, \"!messageId\");\n        assembly {\n            _msgDataMessageId := calldataload(sub(calldatasize(), 84))\n        }\n    }\n\n    /// @notice The cross-chain message source chainId\n    function _fromChainId() internal pure returns (uint256 _msgDataFromChainId) {\n        require(msg.data.length >= 52, \"!fromChainId\");\n        assembly {\n            _msgDataFromChainId := calldataload(sub(calldatasize(), 52))\n        }\n    }\n\n    /// @notice Get the source chain fromDapp address.\n    function _xmsgSender() internal pure returns (address payable _from) {\n        require(msg.data.length >= 20, \"!fromDapp\");\n        assembly {\n            _from := shr(96, calldataload(sub(calldatasize(), 20)))\n        }\n    }\n}\n"
			},
			"lib/XAccount/src/XAccountFactory.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./interfaces/ISafeMsgportModule.sol\";\nimport \"./interfaces/ISafeProxyFactory.sol\";\nimport \"./interfaces/ISafe.sol\";\nimport \"./utils/CREATE3.sol\";\n\n/// @title XAccountFactory\n/// @dev XAccountFactory is a factory contract for create xAccount.\n///   - 1 account can deploy multi xAccount on target chain for each factory.\ncontract XAccountFactory {\n    address public immutable SAFE_MSGPORT_MODULE;\n    /// Safe Deployment: https://github.com/safe-global/safe-deployments/tree/main/src/assets/v1.3.0\n    address public constant safeFallbackHandler = 0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4;\n    address public constant safeSingletonL2 = 0x3E5c63644E683549055b9Be8653de26E0B4CD36E;\n    ISafeProxyFactory public constant safeFactory = ISafeProxyFactory(0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2);\n\n    address internal constant DEAD_OWNER = 0xDDdDddDdDdddDDddDDddDDDDdDdDDdDDdDDDDDDd;\n\n    event XAccountCreated(\n        address deployer,\n        bytes32 salt,\n        uint256 fromChainId,\n        address owner,\n        address xAccount,\n        address module,\n        address port,\n        address recovery\n    );\n\n    constructor(address safeMsgportModule) {\n        SAFE_MSGPORT_MODULE = safeMsgportModule;\n    }\n\n    /// @dev Create xAccount on target chain.\n    /// @param salt Pseudo random number.\n    /// @param fromChainId Source chain id.\n    /// @param owner Owner on source chain.\n    /// @param port Msgport address for send msgport.\n    /// @param recovery The default safe recovery module address for xAccount.\n    /// @return Deployed xAccount address.\n    function create(bytes32 salt, uint256 fromChainId, address owner, address port, address recovery)\n        external\n        returns (address, address)\n    {\n        return _deploy(salt, fromChainId, owner, port, recovery);\n    }\n\n    function _deploy(bytes32 salt, uint256 fromChainId, address owner, address port, address recovery)\n        internal\n        returns (address proxy, address module)\n    {\n        address deployer = msg.sender;\n        salt = keccak256(abi.encodePacked(deployer, salt, fromChainId, owner));\n        (proxy, module) = _deployXAccount(salt);\n        _setupProxy(proxy, module, recovery);\n        _setupModule(module, proxy, fromChainId, owner, port);\n\n        emit XAccountCreated(deployer, salt, fromChainId, owner, proxy, module, port, recovery);\n    }\n\n    function setupModules(address module, address recovery) external {\n        ISafe safe = ISafe(address(this));\n        safe.enableModule(module);\n        if (recovery != address(0)) safe.enableModule(recovery);\n    }\n\n    function _setupProxy(address proxy, address module, address recovery) internal {\n        bytes memory setupModulesData = abi.encodeWithSelector(XAccountFactory.setupModules.selector, module, recovery);\n        uint256 threshold = 1;\n        address[] memory owners = new address[](1);\n        owners[0] = DEAD_OWNER;\n        ISafe(proxy).setup(\n            owners,\n            threshold,\n            address(this),\n            setupModulesData,\n            safeFallbackHandler,\n            address(0x0),\n            0,\n            payable(address(0x0))\n        );\n    }\n\n    function _setupModule(address module, address proxy, uint256 chainId, address owner, address port) internal {\n        ISafeMsgportModule(module).setup(proxy, chainId, owner, port);\n    }\n\n    function _deployXAccount(bytes32 salt) internal returns (address proxy, address module) {\n        (proxy, module) = CREATE3.getDeployed(salt, address(this));\n        bytes memory creationCode1 = safeFactory.proxyCreationCode();\n        bytes memory deploymentCode1 = abi.encodePacked(creationCode1, uint256(uint160(safeSingletonL2)));\n\n        (proxy, module) = CREATE3.deploy(salt, deploymentCode1, SAFE_MSGPORT_MODULE);\n    }\n\n    /// @dev Calculate xAccount address.\n    /// @notice The module address is only effective during its creation and may be replaced by the xAccount in the future.\n    /// @param deployer who deployed the xAccount.\n    /// @param salt Pseudo random number of deplyed xAccount.\n    /// @param fromChainId Chain id that xAccount belongs in.\n    /// @param owner Owner that xAccount belongs to.\n    /// @return (xAccount address, module address).\n    function xAccountOf(address deployer, bytes32 salt, uint256 fromChainId, address owner)\n        public\n        view\n        returns (address, address)\n    {\n        salt = keccak256(abi.encodePacked(deployer, salt, fromChainId, owner));\n        return CREATE3.getDeployed(salt, address(this));\n    }\n}\n"
			},
			"lib/XAccount/src/interfaces/ISafeMsgportModule.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface ISafeMsgportModule {\n    function setup(address xAccount, uint256 chainId, address owner, address port_) external;\n}\n"
			},
			"lib/XAccount/src/interfaces/ISafeProxyFactory.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface ISafeProxyFactory {\n    function proxyCreationCode() external pure returns (bytes memory);\n}\n"
			},
			"lib/XAccount/src/utils/CREATE3.sol": {
				"content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Bytes32AddressLib} from \"solmate/utils/Bytes32AddressLib.sol\";\n\n/// @notice Deploy to deterministic addresses without an initcode factor.\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/CREATE3.sol)\nlibrary CREATE3 {\n    using Bytes32AddressLib for bytes32;\n\n    //--------------------------------------------------------------------------------//\n    // Opcode     | Opcode + Arguments    | Description      | Stack View             //\n    //--------------------------------------------------------------------------------//\n    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 0 size               //\n    // 0x37       |  0x37                 | CALLDATACOPY     |                        //\n    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //\n    // 0x34       |  0x34                 | CALLVALUE        | value 0 size           //\n    // 0xf0       |  0xf0                 | CREATE           | newContract            //\n    //--------------------------------------------------------------------------------//\n    // Opcode     | Opcode + Arguments    | Description      | Stack View             //\n    //--------------------------------------------------------------------------------//\n    // 0x67       |  0x67XXXXXXXXXXXXXXXX | PUSH8 bytecode   | bytecode               //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 bytecode             //\n    // 0x52       |  0x52                 | MSTORE           |                        //\n    // 0x60       |  0x6008               | PUSH1 08         | 8                      //\n    // 0x60       |  0x6018               | PUSH1 18         | 24 8                   //\n    // 0xf3       |  0xf3                 | RETURN           |                        //\n    //--------------------------------------------------------------------------------//\n    bytes internal constant PROXY_BYTECODE = hex\"67363d3d37363d34f03d5260086018f3\";\n\n    bytes32 internal constant PROXY_BYTECODE_HASH = keccak256(PROXY_BYTECODE);\n\n    function deploy(bytes32 salt, bytes memory creationCode1, address implementation)\n        internal\n        returns (address deployed1, address deployed2)\n    {\n        bytes memory proxyChildBytecode = PROXY_BYTECODE;\n\n        address proxy;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Deploy a new contract with our pre-made bytecode via CREATE2.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            proxy := create2(0, add(proxyChildBytecode, 32), mload(proxyChildBytecode), salt)\n        }\n        require(proxy != address(0), \"DEPLOYMENT_FAILED\");\n\n        (deployed1, deployed2) = getDeployed(salt, address(this));\n        (bool success,) = proxy.call(creationCode1);\n        require(success && deployed1.code.length != 0, \"INITIALIZATION_FAILED1\");\n        bytes memory creationCode2 = clone(implementation);\n        (success,) = proxy.call(creationCode2);\n        require(success && deployed2.code.length != 0, \"INITIALIZATION_FAILED2\");\n    }\n\n    function clone(address target) internal pure returns (bytes memory) {\n        bytes20 targetBytes = bytes20(target);\n        bytes memory code = new bytes(0x37);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(code, 0x20), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(code, 0x34), targetBytes)\n            mstore(add(code, 0x48), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n        }\n        return code;\n    }\n\n    function getDeployed(bytes32 salt, address factory) internal pure returns (address, address) {\n        address proxy = keccak256(abi.encodePacked(bytes1(0xFF), factory, salt, PROXY_BYTECODE_HASH))\n            // Prefix:\n            // Creator:\n            // Salt:\n            // Bytecode hash:\n            .fromLast20Bytes();\n\n        address deployed1 = keccak256(abi.encodePacked(hex\"d694\", proxy, hex\"01\")) // Nonce of the proxy contract (1)\n            // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01)\n            // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n            .fromLast20Bytes();\n\n        address deployed2 = keccak256(abi.encodePacked(hex\"d694\", proxy, hex\"02\")) // Nonce of the proxy contract (2)\n            // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x02)\n            // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n            .fromLast20Bytes();\n        return (deployed1, deployed2);\n    }\n}\n"
			},
			"lib/darwinia-msgport/lib/solmate/src/utils/Bytes32AddressLib.sol": {
				"content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Library for converting between addresses and bytes32 values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/Bytes32AddressLib.sol)\nlibrary Bytes32AddressLib {\n    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue));\n    }\n}\n"
			},
			"lib/XAccount/src/XAccountUIFactory.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"./interfaces/IXAccountFactory.sol\";\n\ncontract XAccountUIFactory {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    IXAccountFactory public immutable FACTORY;\n\n    // fromChainId => owner => xAccounts\n    mapping(uint256 => mapping(address => EnumerableSet.AddressSet)) private _xAccounts;\n    // fromChainId => owner => module\n    mapping(uint256 => mapping(address => EnumerableSet.AddressSet)) private _modules;\n    // fromChainId => owner => xAccounts => deployer\n    mapping(uint256 => mapping(address => mapping(address => address))) public deployers;\n\n    constructor(address factory) {\n        FACTORY = IXAccountFactory(factory);\n    }\n\n    /// Create xAccount using deployer(msg.sender) as salt.\n    function create(uint256 fromChainId, address owner, address port, address recovery)\n        external\n        returns (address xAccount, address module)\n    {\n        address deployer = msg.sender;\n        bytes32 salt = keccak256(abi.encodePacked(deployer));\n        (xAccount, module) = FACTORY.create(salt, fromChainId, owner, port, recovery);\n        require(_xAccounts[fromChainId][owner].add(xAccount), \"!addXAccunt\");\n        require(_modules[fromChainId][owner].add(module), \"!addModule\");\n        deployers[fromChainId][owner][xAccount] = deployer;\n    }\n\n    /// Get all deployed xAccount by xOwner(fromChainId, owner).\n    function getDeployed(uint256 fromChainId, address owner) public view returns (address[] memory, address[] memory) {\n        return (_xAccounts[fromChainId][owner].values(), _modules[fromChainId][owner].values());\n    }\n\n    /// Caculate xAccount address.\n    function xAccountOf(address deployer, uint256 fromChainId, address owner) public view returns (address, address) {\n        bytes32 salt = keccak256(abi.encodePacked(deployer));\n        return FACTORY.xAccountOf(address(this), salt, fromChainId, owner);\n    }\n}\n"
			},
			"lib/XAccount/src/interfaces/IXAccountFactory.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IXAccountFactory {\n    function create(bytes32 salt, uint256 fromChainId, address owner, address port, address recovery)\n        external\n        returns (address, address);\n\n    function xAccountOf(address deployer, bytes32 salt, uint256 fromChainId, address owner)\n        external\n        view\n        returns (address, address);\n}\n"
			},
			"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
			}
		}
	}
}